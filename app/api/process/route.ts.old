import Replicate from "replicate";
import { put, del } from '@vercel/blob';
import { verifyRequestAuth } from '@/lib/auth';
import { processRateLimit, getClientIdentifier, checkRateLimit } from '@/lib/rate-limit';
import { logTranscription, logSummary } from '@/lib/usage-tracking';

export async function POST(request: Request) {
  try {
    // SECURITY: Verify authentication
    const user = verifyRequestAuth(request);
    if (!user) {
      return Response.json({ error: 'No autorizado' }, { status: 401 });
    }

    // SECURITY: Rate limiting
    const identifier = getClientIdentifier(request, user.userId);
    const rateLimitResponse = await checkRateLimit(processRateLimit, identifier, 'transcripciones procesadas');
    if (rateLimitResponse) return rateLimitResponse;

    const { audioUrl, filename } = await request.json();
    
    const replicate = new Replicate({ auth: process.env.REPLICATE_API_TOKEN });
    const output: any = await replicate.run(
      "openai/whisper:4d50797290df275329f202e48c76360b3f22b08d28c196cbc54600319435f8d2",
      { input: { audio: audioUrl, language: "Spanish" }}
    );

    // DEBUG: Log the complete output structure
    console.log('Replicate Whisper output:', JSON.stringify(output, null, 2));

    const text = output.transcription || output.text || '';
    const segments = output.segments || [];

    console.log('Extracted text length:', text.length);
    console.log('Segments count:', segments.length);
    const baseName = filename.replace(/\.[^/.]+$/, '');
    
    const txtBlob = await put(`${baseName}.txt`, text, {
      access: 'public',
      contentType: 'text/plain; charset=utf-8',
      token: process.env.BLOB_READ_WRITE_TOKEN,
      addRandomSuffix: true
    });
    
    let srt = '';
    segments.forEach((seg: any, i: number) => {
      const start = formatTime(seg.start);
      const end = formatTime(seg.end);
      srt += `${i + 1}\n${start} --> ${end}\n${seg.text.trim()}\n\n`;
    });
    const srtBlob = await put(`${baseName}.srt`, srt, {
      access: 'public',
      contentType: 'text/plain; charset=utf-8',
      token: process.env.BLOB_READ_WRITE_TOKEN,
      addRandomSuffix: true
    });

    // TRACKING: Log transcription
    await logTranscription(user.userId, filename);

    let summaryUrl = null;
    if (text.length > 100) {
      try {
        const summaryRes = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': process.env.CLAUDE_API_KEY!,
            'anthropic-version': '2023-06-01'
          },
          body: JSON.stringify({
            model: 'claude-3-5-sonnet-20241022',
            max_tokens: 2000,
            messages: [{ role: 'user', content: `Resume en español en 3-4 párrafos:\n\n${text.slice(0, 8000)}` }]
          })
        });
        const summaryData = await summaryRes.json();
        const summary = summaryData.content[0].text;
        const summaryBlob = await put(`${baseName}-summary.txt`, summary, {
          access: 'public',
          contentType: 'text/plain; charset=utf-8',
          token: process.env.BLOB_READ_WRITE_TOKEN,
          addRandomSuffix: true
        });
        summaryUrl = summaryBlob.url;

        // TRACKING: Log summary generation
        const tokensInput = text.slice(0, 8000).length / 4; // Rough estimate: 4 chars = 1 token
        const tokensOutput = summary.length / 4;
        await logSummary(user.userId, Math.ceil(tokensInput), Math.ceil(tokensOutput), 'sonnet');
      } catch (e) {
        console.log('Summary failed:', e);
      }
    }
    
    return Response.json({
      success: true,
      txtUrl: txtBlob.url,
      srtUrl: srtBlob.url,
      summaryUrl
    });

    // Delete original audio file after successful processing
    try {
      const blobToken = process.env.BLOB_READ_WRITE_TOKEN;
      if (blobToken) {
        await del(audioUrl, { token: blobToken });
        console.log(`[Vercel Blob] Deleted original audio file: ${audioUrl}`);
      } else {
        console.warn('[Vercel Blob] BLOB_READ_WRITE_TOKEN not configured, skipping original file deletion.');
      }
    } catch (deleteError: any) {
      console.error(`[Vercel Blob] Failed to delete original audio file ${audioUrl}:`, deleteError.message);
    }
    
  } catch (error: any) {
    console.error('Process error:', error);
    return Response.json({ error: error.message }, { status: 500 });
  }
}

function formatTime(seconds: number) {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);
  return `${pad(h)}:${pad(m)}:${pad(s)},${pad(ms, 3)}`;
}

function pad(num: number, size = 2) {
  return String(num).padStart(size, '0');
}
